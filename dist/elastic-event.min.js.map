{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///elastic-event.min.js","webpack:///webpack/bootstrap d7d0431e061aab4972b1","webpack:///./elastic-event.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","ElasticEvent","options","opts","host","index","type","queue","max","traits","interval","intervalSend","beforeunload","setupIntervalSend","setupBeforeUnload","prototype","xhr","url","content","sync","callback","XMLHttpRequest","ontimeout","onerror","onload","err","status","Error","statusText","responseText","JSON","parse","open","setRequestHeader","send","request","data","json","op","stringify","length","splice","join","add","event","meta","info","_index","_type","_id","push","baseEvent","trait","hasOwnProperty","track","identify","search","query","setInterval","bind","window","addEventListener","close","clearInterval","removeEventListener","self"],"mappings":"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","file":"elastic-event.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ElasticEvent\"] = factory();\n\telse\n\t\troot[\"ElasticEvent\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ElasticEvent\"] = factory();\n\telse\n\t\troot[\"ElasticEvent\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\n\t * ElasticEvent provides a simple interface to log and query event. Requests\n\t * to the ElasticSearch API are sent in bulk by keeping a queue of\n\t * logged events that will be sent on a set interval, before\n\t * unload, on max size or on command.\n\t *\n\t * @class ElasticEvent\n\t *\n\t * @param {object} [options]                      - elastic event defaults\n\t * @param {string} [options.host=localhost:9200]  - elasticsearch host\n\t * @param {string} [options.index]                - default request index\n\t * @param {string} [options.type]                 - default request type\n\t * @param {number} [options.max=256]              - default max queue length\n\t * @param {number} [options.interval=10000]       - default interval (ms) between\n\t *                                                \tsending bulk requests\n\t * @param {boolean} [options.setupIntervalSend]   - setups the repeating sending\n\t *                                                \tof bulk requests for the set\n\t *                                                \tinterval\n\t * @param {boolean} [options.setupBeforeUnload]   - setups sending bulk requests\n\t *                                                \tbefore window unload\n\t * @constructor\n\t */\n\tfunction ElasticEvent(options) {\n\t  var opts = options || {};\n\t\n\t  // make sure it is initialized with the 'new' constructor\n\t  if (!(this instanceof ElasticEvent)) {\n\t    return new ElasticEvent(opts);\n\t  }\n\t\n\t  /**\n\t   * ElasticSearch API host url\n\t   * @private\n\t   * @type {string}\n\t   */\n\t  this.host = opts.host || 'localhost:9200';\n\t\n\t  /**\n\t   * index value to use for the endpoint url construction\n\t   * (eg. localhost:9200/{index}/_bulk)\n\t   * @private\n\t   * @type {string}\n\t   */\n\t  this.index = opts.index;\n\t\n\t  /**\n\t   * type value to use for the endpoint url construction\n\t   * @private\n\t   * @type {string}\n\t   */\n\t  this.type = opts.type;\n\t\n\t  /**\n\t   * @external BulkRequest\n\t   * @private\n\t   * @example\n\t   * '{ \"index\" : { \"_index\" : \"test\", \"_type\" : \"type1\", \"_id\" : \"1\" } }\\n\n\t   * { \"field1\" : \"value1\" }\\n'\n\t   * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html bulk API}\n\t   */\n\t\n\t  /**\n\t   * store of bulk requests\n\t   * @private\n\t   * @type {Array.external:BulkRequest}\n\t   */\n\t  this.queue = [];\n\t\n\t  /**\n\t   * default max length of queue\n\t   * @private\n\t   * @type {number}\n\t   */\n\t  this.max = opts.max || 256;\n\t\n\t  /**\n\t   * traits associated to all events logged may be used to identify sources\n\t   * of logs\n\t   * @private\n\t   * @type {object}\n\t   */\n\t  this.traits = {};\n\t\n\t  /**\n\t   * interval (ms) between sending bulk request\n\t   * @private\n\t   * @type {number}\n\t   */\n\t  this.interval = opts.interval || 10000;\n\t\n\t  /**\n\t   * interval ID of the setup repeating call\n\t   * @private\n\t   * @type {number}\n\t   */\n\t  this.intervalSend = null;\n\t\n\t  /**\n\t   * beforeunload event handler called when 'beforeunload' event is triggered\n\t   * @private\n\t   * @type {function}\n\t   */\n\t  this.beforeunload = null;\n\t\n\t  if (opts.setupIntervalSend) {\n\t    this.setupIntervalSend();\n\t  }\n\t  if (opts.setupBeforeUnload) {\n\t    this.setupBeforeUnload();\n\t  }\n\t}\n\t\n\t/**\n\t * @external response\n\t * @example\n\t * var response = {\n\t *     \"_shards\":{\n\t *         \"total\" : 5,\n\t *         \"successful\" : 5,\n\t *         \"failed\" : 0\n\t *     },\n\t *  \"hits\":{\n\t *      \"total\" : 1,\n\t *      \"hits\" : [\n\t *          {\n\t *              \"_index\" : \"twitter\",\n\t *              \"_type\" : \"tweet\",\n\t *                \"_id\" : \"1\",\n\t *                \"_source\" : {\n\t *                    \"user\" : \"kimchy\",\n\t *                    \"postDate\" : \"2009-11-15T14:12:12\",\n\t *                    \"message\" : \"trying out Elasticsearch\"\n\t *                }\n\t *            }\n\t *        ]\n\t *    }\n\t * };\n\t * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html ElasticSearch API}\n\t */\n\t\n\t/**\n\t * This callback is displayed as part of the Requester class.\n\t * @callback ElasticEvent~requestCallback\n\t * @param {Error | null}                                    error\n\t * @param {external:response | object | null}               response\n\t * @param {number}                                          status\n\t */\n\t\n\t/**\n\t * xhr helper function to request the ElasticSearch API without preflight\n\t * @private\n\t *\n\t * @param  {string} url                   - endpoint\n\t * @param  {string} content               - body content\n\t * @param  {boolean} sync                 - set true if synchronous request\n\t * @param  {ElasticEvent~requestCallback} [callback]  - called on load, timeout\n\t *                                                   \t\tor on error\n\t * @return {ElasticSearch}                - chainable\n\t */\n\tElasticEvent.prototype.xhr = function (url, content, sync, callback) {\n\t  var xhr = new XMLHttpRequest();\n\t\n\t  if (typeof callback === 'function') {\n\t    xhr.ontimeout = xhr.onerror = xhr.onload = function () {\n\t      var err = null;\n\t      if (!xhr.status || xhr.status >= 400) {\n\t        err = new Error(xhr.statusText || 'request failed');\n\t      }\n\t      callback(err, xhr.responseText ? JSON.parse(xhr.responseText) : null,\n\t        xhr.status, xhr);\n\t    };\n\t  }\n\t\n\t  xhr.open('POST', url, !sync);\n\t\n\t  if (content) {\n\t    // no preflight\n\t    xhr.setRequestHeader('Content-Type', 'text/plain');\n\t    xhr.send(content);\n\t  } else {\n\t    xhr.send(null);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * @typedef {object} ElasticEvent~requestOptions\n\t * @property {string}   [url]               - overides request url construction\n\t * @property {string}   [host=this.host]    - request host\n\t * @property {string}   [index=this.index]  - request index\n\t * @property {string}   [type=this.type]    - request type\n\t * @property {string}   [op=search]         - request operation\n\t * @property {boolean}  [sync]              - synchronous request\n\t */\n\t\n\t/**\n\t * request the ElasticSearch API by building the request url from options and\n\t * instance defaults: url = {host}/{index}/{type}/_{op}\n\t *\n\t * @param  {object | string}              [data]      - body content of the request\n\t * @param  {ElasticEvent~requestOptions}  [options]   - request options\n\t * @param  {ElasticEvent~requestCallback} [callback]  - request callback\n\t * @return {ElasticEvent}                             - chainable\n\t */\n\tElasticEvent.prototype.request = function (data, options, callback) {\n\t  var opts = options || {};\n\t  var json;\n\t  var url = opts.url || opts.host || this.host;\n\t\n\t  if (!opts.url) {\n\t    if (opts.index || this.index) {\n\t      url += '/' + (opts.index || this.index);\n\t    }\n\t    if (opts.type || this.type) {\n\t      url += '/' + (opts.type || this.type);\n\t    }\n\t\n\t    url += '/_' + (opts.op || 'search');\n\t  }\n\t\n\t  if (data && typeof data === 'object') {\n\t    json = JSON.stringify(data);\n\t  }\n\t\n\t  this.xhr(url, json || data, opts.sync, callback);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * send the bulk queued requests\n\t * @param  {ElasticEvent~requestOptions}  [options]     - request options\n\t * @param  {ElasticEvent~requestCallback} [callback]    - request callback\n\t * @return {ElasticEvent}                               - chainable\n\t */\n\tElasticEvent.prototype.send = function (options, callback) {\n\t  var opts = options || {};\n\t\n\t  if (!this.queue.length) {\n\t    return this;\n\t  }\n\t\n\t  opts.op = 'bulk';\n\t\n\t  this.request(\n\t    this.queue.splice(0, opts.max || this.max).join(''),\n\t    opts,\n\t    callback\n\t  );\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * add event data as a index bulk request to the queue,\n\t * if queue length is superior to this.max length will send all queued requests\n\t * @private\n\t *\n\t * @param  {object}  event                    - event/document to be added\n\t * @param  {object}  [meta]                   - meta data on this document\n\t * @param  {string}  [meta.index=this.index]  - set this specific event index\n\t * @param  {string}  [meta.type=this.type]    - set this specific event type\n\t * @param  {string}  [meta.id]                - set this specific event id\n\t * @return {ElasticEvent}                     - chainable\n\t */\n\tElasticEvent.prototype.add = function (event, meta) {\n\t  var data;\n\t  var info = meta || {};\n\t  var index = {\n\t    _index: info.index || this.index,\n\t    _type: info.type || this.type\n\t  };\n\t\n\t  if (typeof event !== 'object') {\n\t    throw new Error('log event is not an object');\n\t  }\n\t\n\t  if (info.id) {\n\t    index._id = info.id;\n\t  }\n\t\n\t  data = JSON.stringify({ index: index }) + '\\n' +\n\t    JSON.stringify(event) + '\\n';\n\t\n\t  this.queue.push(data);\n\t\n\t  if (this.queue.length > this.max) {\n\t    this.send();\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * baseEvent helper function to mixin this.traits to the event provided\n\t * @private\n\t *\n\t * @param  {object} [event] - event/document data\n\t * @return {object}         - mixed in traits with event object\n\t */\n\tElasticEvent.prototype.baseEvent = function (event) {\n\t  var baseEvent = event || {};\n\t  var trait;\n\t\n\t  for (trait in this.traits) {\n\t    // makes sure no inherited prototype get included\n\t    if (this.traits.hasOwnProperty(trait) &&\n\t      // only sets a trait if it is not present in the event object\n\t      !baseEvent.hasOwnProperty(trait)) {\n\t      baseEvent[trait] = this.traits[trait];\n\t    }\n\t  }\n\t\n\t  return baseEvent;\n\t};\n\t\n\t/**\n\t * track events you will need to specify the event type, this will mixin the\n\t * event with this.traits and add it to the queued requests\n\t *\n\t * @throws 'invalid type' if type parameter is not a string\n\t * @param  {string} type    - event type\n\t * @param  {object} [event] - event/document data\n\t * @return {ElasticEvent}   - chainable\n\t */\n\tElasticEvent.prototype.track = function (type, event) {\n\t  if (typeof type !== 'string') {\n\t    throw new Error('invalid type');\n\t  }\n\t\n\t  return this.add(this.baseEvent(event), {\n\t    type: type\n\t  });\n\t};\n\t\n\t/**\n\t * identify the events with the given traits, overides previously set traits,\n\t * will apply only to future events\n\t *\n\t * @param  {object} traits  - set traits to all events\n\t * @return {ElasticEvent}   - chainable\n\t */\n\tElasticEvent.prototype.identify = function (traits) {\n\t  var trait;\n\t\n\t  for (trait in traits) {\n\t    if (traits.hasOwnProperty(trait)) {\n\t      this.traits[trait] = traits[trait];\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Query the event with the QueryDSL of ElasticSearch API\n\t * The elastic.js or bodybuilder libraries can be used to make building request\n\t * bodies simpler.\n\t * @external requestBodySearch\n\t * @example <caption>query of documents with user field equal to kimchy</caption>\n\t * var requestBodySearch = {\n\t *   \"query\" : {\n\t *     \"term\" : { \"user\" : \"kimchy\" }\n\t * };\n\t * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html request body search API}\n\t * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html Query DSL}\n\t * @see {@link https://github.com/fullscale/elastic.js/ elastic.js}\n\t * @see {@link https://github.com/danpaz/bodybuilder bodybuilder}\n\t */\n\t\n\t/**\n\t * search using the ElasticSearch API with the given body query\n\t * @param  {external:requestBodySearch}   [query]     - body search\n\t * @param  {ElasticEvent~requestOptions}  [options]   - options\n\t * @param  {ElasticEvent~requestCallback} [callback]  - callback\n\t * @return {ElasticEvent}                             - chainable\n\t *\n\t */\n\tElasticEvent.prototype.search = function (query, options, callback) {\n\t  var opts = options || {};\n\t\n\t  opts.op = 'search';\n\t\n\t  this.request(\n\t    query,\n\t    opts,\n\t    callback\n\t  );\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * setupIntervalSend setups the repeating call to empty the queue of logged\n\t * events, interval id is stored in this.intervalSend.\n\t * @private\n\t *\n\t * @throws 'already setup intervalSend' if this.intervalSend is already set\n\t * @param  {number} [interval]    - interval (ms) of the repeating call\n\t * @return {ElasticEvent}         - chainable\n\t */\n\tElasticEvent.prototype.setupIntervalSend = function (interval) {\n\t  if (this.intervalSend) {\n\t    throw new Error('already setup intervalSend');\n\t  }\n\t\n\t  this.interval = interval || this.interval;\n\t\n\t  this.intervalSend = setInterval(\n\t    this.send.bind(this,\n\t      // will use instance setup options\n\t      null,\n\t      // no callback\n\t      null),\n\t    this.interval\n\t  );\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * setupBeforeUnload setups the synchronous call before unload of html document\n\t * @private\n\t *\n\t * @throws 'already setup beforeUnload' if this.beforeunload is already set\n\t * @return {ElasticEvent}   - chainable\n\t */\n\tElasticEvent.prototype.setupBeforeUnload = function () {\n\t  if (this.beforeunload) {\n\t    throw new Error('already setup beforeUnload');\n\t  }\n\t\n\t  this.beforeunload = this.send.bind(this, {\n\t    sync: true\n\t  }, null);\n\t\n\t  window.addEventListener('beforeunload', this.beforeunload);\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * close empties the queue of logged events and removes the listener on\n\t * beforeunload and clears interval\n\t *\n\t * @param  {ElasticEvent~requestOptions}  [options]     - request options\n\t * @param  {ElasticEvent~requestCallback} [callback]    - request callback\n\t * @return {ElasticEvent}                               - chainable\n\t */\n\tElasticEvent.prototype.close = function (options, callback) {\n\t  if (this.intervalSend) {\n\t    clearInterval(this.intervalSend);\n\t    this.intervalSend = null;\n\t  }\n\t  if (this.beforeunload) {\n\t    window.removeEventListener('beforeunload', this.beforeunload);\n\t    this.beforeunload = null;\n\t  }\n\t  self.send(options, callback);\n\t\n\t  return this;\n\t};\n\t\n\tmodule.exports = ElasticEvent;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** elastic-event.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d7d0431e061aab4972b1\n **/","/**\n * ElasticEvent provides a simple interface to log and query event. Requests\n * to the ElasticSearch API are sent in bulk by keeping a queue of\n * logged events that will be sent on a set interval, before\n * unload, on max size or on command.\n *\n * @class ElasticEvent\n *\n * @param {object} [options]                      - elastic event defaults\n * @param {string} [options.host=localhost:9200]  - elasticsearch host\n * @param {string} [options.index]                - default request index\n * @param {string} [options.type]                 - default request type\n * @param {number} [options.max=256]              - default max queue length\n * @param {number} [options.interval=10000]       - default interval (ms) between\n *                                                \tsending bulk requests\n * @param {boolean} [options.setupIntervalSend]   - setups the repeating sending\n *                                                \tof bulk requests for the set\n *                                                \tinterval\n * @param {boolean} [options.setupBeforeUnload]   - setups sending bulk requests\n *                                                \tbefore window unload\n * @constructor\n */\nfunction ElasticEvent(options) {\n  var opts = options || {};\n\n  // make sure it is initialized with the 'new' constructor\n  if (!(this instanceof ElasticEvent)) {\n    return new ElasticEvent(opts);\n  }\n\n  /**\n   * ElasticSearch API host url\n   * @private\n   * @type {string}\n   */\n  this.host = opts.host || 'localhost:9200';\n\n  /**\n   * index value to use for the endpoint url construction\n   * (eg. localhost:9200/{index}/_bulk)\n   * @private\n   * @type {string}\n   */\n  this.index = opts.index;\n\n  /**\n   * type value to use for the endpoint url construction\n   * @private\n   * @type {string}\n   */\n  this.type = opts.type;\n\n  /**\n   * @external BulkRequest\n   * @private\n   * @example\n   * '{ \"index\" : { \"_index\" : \"test\", \"_type\" : \"type1\", \"_id\" : \"1\" } }\\n\n   * { \"field1\" : \"value1\" }\\n'\n   * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html bulk API}\n   */\n\n  /**\n   * store of bulk requests\n   * @private\n   * @type {Array.external:BulkRequest}\n   */\n  this.queue = [];\n\n  /**\n   * default max length of queue\n   * @private\n   * @type {number}\n   */\n  this.max = opts.max || 256;\n\n  /**\n   * traits associated to all events logged may be used to identify sources\n   * of logs\n   * @private\n   * @type {object}\n   */\n  this.traits = {};\n\n  /**\n   * interval (ms) between sending bulk request\n   * @private\n   * @type {number}\n   */\n  this.interval = opts.interval || 10000;\n\n  /**\n   * interval ID of the setup repeating call\n   * @private\n   * @type {number}\n   */\n  this.intervalSend = null;\n\n  /**\n   * beforeunload event handler called when 'beforeunload' event is triggered\n   * @private\n   * @type {function}\n   */\n  this.beforeunload = null;\n\n  if (opts.setupIntervalSend) {\n    this.setupIntervalSend();\n  }\n  if (opts.setupBeforeUnload) {\n    this.setupBeforeUnload();\n  }\n}\n\n/**\n * @external response\n * @example\n * var response = {\n *     \"_shards\":{\n *         \"total\" : 5,\n *         \"successful\" : 5,\n *         \"failed\" : 0\n *     },\n *  \"hits\":{\n *      \"total\" : 1,\n *      \"hits\" : [\n *          {\n *              \"_index\" : \"twitter\",\n *              \"_type\" : \"tweet\",\n *                \"_id\" : \"1\",\n *                \"_source\" : {\n *                    \"user\" : \"kimchy\",\n *                    \"postDate\" : \"2009-11-15T14:12:12\",\n *                    \"message\" : \"trying out Elasticsearch\"\n *                }\n *            }\n *        ]\n *    }\n * };\n * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html ElasticSearch API}\n */\n\n/**\n * This callback is displayed as part of the Requester class.\n * @callback ElasticEvent~requestCallback\n * @param {Error | null}                                    error\n * @param {external:response | object | null}               response\n * @param {number}                                          status\n */\n\n/**\n * xhr helper function to request the ElasticSearch API without preflight\n * @private\n *\n * @param  {string} url                   - endpoint\n * @param  {string} content               - body content\n * @param  {boolean} sync                 - set true if synchronous request\n * @param  {ElasticEvent~requestCallback} [callback]  - called on load, timeout\n *                                                   \t\tor on error\n * @return {ElasticSearch}                - chainable\n */\nElasticEvent.prototype.xhr = function (url, content, sync, callback) {\n  var xhr = new XMLHttpRequest();\n\n  if (typeof callback === 'function') {\n    xhr.ontimeout = xhr.onerror = xhr.onload = function () {\n      var err = null;\n      if (!xhr.status || xhr.status >= 400) {\n        err = new Error(xhr.statusText || 'request failed');\n      }\n      callback(err, xhr.responseText ? JSON.parse(xhr.responseText) : null,\n        xhr.status, xhr);\n    };\n  }\n\n  xhr.open('POST', url, !sync);\n\n  if (content) {\n    // no preflight\n    xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.send(content);\n  } else {\n    xhr.send(null);\n  }\n\n  return this;\n};\n\n/**\n * @typedef {object} ElasticEvent~requestOptions\n * @property {string}   [url]               - overides request url construction\n * @property {string}   [host=this.host]    - request host\n * @property {string}   [index=this.index]  - request index\n * @property {string}   [type=this.type]    - request type\n * @property {string}   [op=search]         - request operation\n * @property {boolean}  [sync]              - synchronous request\n */\n\n/**\n * request the ElasticSearch API by building the request url from options and\n * instance defaults: url = {host}/{index}/{type}/_{op}\n *\n * @param  {object | string}              [data]      - body content of the request\n * @param  {ElasticEvent~requestOptions}  [options]   - request options\n * @param  {ElasticEvent~requestCallback} [callback]  - request callback\n * @return {ElasticEvent}                             - chainable\n */\nElasticEvent.prototype.request = function (data, options, callback) {\n  var opts = options || {};\n  var json;\n  var url = opts.url || opts.host || this.host;\n\n  if (!opts.url) {\n    if (opts.index || this.index) {\n      url += '/' + (opts.index || this.index);\n    }\n    if (opts.type || this.type) {\n      url += '/' + (opts.type || this.type);\n    }\n\n    url += '/_' + (opts.op || 'search');\n  }\n\n  if (data && typeof data === 'object') {\n    json = JSON.stringify(data);\n  }\n\n  this.xhr(url, json || data, opts.sync, callback);\n\n  return this;\n};\n\n/**\n * send the bulk queued requests\n * @param  {ElasticEvent~requestOptions}  [options]     - request options\n * @param  {ElasticEvent~requestCallback} [callback]    - request callback\n * @return {ElasticEvent}                               - chainable\n */\nElasticEvent.prototype.send = function (options, callback) {\n  var opts = options || {};\n\n  if (!this.queue.length) {\n    return this;\n  }\n\n  opts.op = 'bulk';\n\n  this.request(\n    this.queue.splice(0, opts.max || this.max).join(''),\n    opts,\n    callback\n  );\n\n  return this;\n};\n\n/**\n * add event data as a index bulk request to the queue,\n * if queue length is superior to this.max length will send all queued requests\n * @private\n *\n * @param  {object}  event                    - event/document to be added\n * @param  {object}  [meta]                   - meta data on this document\n * @param  {string}  [meta.index=this.index]  - set this specific event index\n * @param  {string}  [meta.type=this.type]    - set this specific event type\n * @param  {string}  [meta.id]                - set this specific event id\n * @return {ElasticEvent}                     - chainable\n */\nElasticEvent.prototype.add = function (event, meta) {\n  var data;\n  var info = meta || {};\n  var index = {\n    _index: info.index || this.index,\n    _type: info.type || this.type\n  };\n\n  if (typeof event !== 'object') {\n    throw new Error('log event is not an object');\n  }\n\n  if (info.id) {\n    index._id = info.id;\n  }\n\n  data = JSON.stringify({ index: index }) + '\\n' +\n    JSON.stringify(event) + '\\n';\n\n  this.queue.push(data);\n\n  if (this.queue.length > this.max) {\n    this.send();\n  }\n\n  return this;\n};\n\n/**\n * baseEvent helper function to mixin this.traits to the event provided\n * @private\n *\n * @param  {object} [event] - event/document data\n * @return {object}         - mixed in traits with event object\n */\nElasticEvent.prototype.baseEvent = function (event) {\n  var baseEvent = event || {};\n  var trait;\n\n  for (trait in this.traits) {\n    // makes sure no inherited prototype get included\n    if (this.traits.hasOwnProperty(trait) &&\n      // only sets a trait if it is not present in the event object\n      !baseEvent.hasOwnProperty(trait)) {\n      baseEvent[trait] = this.traits[trait];\n    }\n  }\n\n  return baseEvent;\n};\n\n/**\n * track events you will need to specify the event type, this will mixin the\n * event with this.traits and add it to the queued requests\n *\n * @throws 'invalid type' if type parameter is not a string\n * @param  {string} type    - event type\n * @param  {object} [event] - event/document data\n * @return {ElasticEvent}   - chainable\n */\nElasticEvent.prototype.track = function (type, event) {\n  if (typeof type !== 'string') {\n    throw new Error('invalid type');\n  }\n\n  return this.add(this.baseEvent(event), {\n    type: type\n  });\n};\n\n/**\n * identify the events with the given traits, overides previously set traits,\n * will apply only to future events\n *\n * @param  {object} traits  - set traits to all events\n * @return {ElasticEvent}   - chainable\n */\nElasticEvent.prototype.identify = function (traits) {\n  var trait;\n\n  for (trait in traits) {\n    if (traits.hasOwnProperty(trait)) {\n      this.traits[trait] = traits[trait];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Query the event with the QueryDSL of ElasticSearch API\n * The elastic.js or bodybuilder libraries can be used to make building request\n * bodies simpler.\n * @external requestBodySearch\n * @example <caption>query of documents with user field equal to kimchy</caption>\n * var requestBodySearch = {\n *   \"query\" : {\n *     \"term\" : { \"user\" : \"kimchy\" }\n * };\n * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html request body search API}\n * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html Query DSL}\n * @see {@link https://github.com/fullscale/elastic.js/ elastic.js}\n * @see {@link https://github.com/danpaz/bodybuilder bodybuilder}\n */\n\n/**\n * search using the ElasticSearch API with the given body query\n * @param  {external:requestBodySearch}   [query]     - body search\n * @param  {ElasticEvent~requestOptions}  [options]   - options\n * @param  {ElasticEvent~requestCallback} [callback]  - callback\n * @return {ElasticEvent}                             - chainable\n *\n */\nElasticEvent.prototype.search = function (query, options, callback) {\n  var opts = options || {};\n\n  opts.op = 'search';\n\n  this.request(\n    query,\n    opts,\n    callback\n  );\n\n  return this;\n};\n\n/**\n * setupIntervalSend setups the repeating call to empty the queue of logged\n * events, interval id is stored in this.intervalSend.\n * @private\n *\n * @throws 'already setup intervalSend' if this.intervalSend is already set\n * @param  {number} [interval]    - interval (ms) of the repeating call\n * @return {ElasticEvent}         - chainable\n */\nElasticEvent.prototype.setupIntervalSend = function (interval) {\n  if (this.intervalSend) {\n    throw new Error('already setup intervalSend');\n  }\n\n  this.interval = interval || this.interval;\n\n  this.intervalSend = setInterval(\n    this.send.bind(this,\n      // will use instance setup options\n      null,\n      // no callback\n      null),\n    this.interval\n  );\n\n  return this;\n};\n\n/**\n * setupBeforeUnload setups the synchronous call before unload of html document\n * @private\n *\n * @throws 'already setup beforeUnload' if this.beforeunload is already set\n * @return {ElasticEvent}   - chainable\n */\nElasticEvent.prototype.setupBeforeUnload = function () {\n  if (this.beforeunload) {\n    throw new Error('already setup beforeUnload');\n  }\n\n  this.beforeunload = this.send.bind(this, {\n    sync: true\n  }, null);\n\n  window.addEventListener('beforeunload', this.beforeunload);\n\n  return this;\n};\n\n/**\n * close empties the queue of logged events and removes the listener on\n * beforeunload and clears interval\n *\n * @param  {ElasticEvent~requestOptions}  [options]     - request options\n * @param  {ElasticEvent~requestCallback} [callback]    - request callback\n * @return {ElasticEvent}                               - chainable\n */\nElasticEvent.prototype.close = function (options, callback) {\n  if (this.intervalSend) {\n    clearInterval(this.intervalSend);\n    this.intervalSend = null;\n  }\n  if (this.beforeunload) {\n    window.removeEventListener('beforeunload', this.beforeunload);\n    this.beforeunload = null;\n  }\n  self.send(options, callback);\n\n  return this;\n};\n\nmodule.exports = ElasticEvent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./elastic-event.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}