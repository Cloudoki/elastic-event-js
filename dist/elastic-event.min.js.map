{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///elastic-event.min.js","webpack:///webpack/bootstrap 8256de9b3d20f4b4b55a","webpack:///./elastic-event.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","ElasticEvent","host","index","type","queue","max","traits","interval","intervalSend","beforeunload","prototype","xhr","url","content","sync","callback","XMLHttpRequest","ontimeout","onerror","onload","err","status","Error","statusText","responseText","JSON","parse","open","setRequestHeader","send","options","opts","length","op","request","splice","join","data","json","stringify","add","event","meta","info","_index","_type","_id","push","baseEvent","trait","hasOwnProperty","track","identify","search","query","setupIntervalSend","setInterval","bind","setupBeforeUnload","window","addEventListener","setup","close","clearInterval","removeEventListener","self"],"mappings":"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","file":"elastic-event.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ElasticEvent\"] = factory();\n\telse\n\t\troot[\"ElasticEvent\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ElasticEvent\"] = factory();\n\telse\n\t\troot[\"ElasticEvent\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/**\n\t * ElasticEvent provides a simple interface to log and query event. Requests\n\t * to the ElasticSearch API are sent in bulk by keeping a queue of\n\t * logged events that will be sent on a set interval, before\n\t * unload, on max size or on command.\n\t *\n\t * @class ElasticEvent\n\t * @constructor\n\t */\n\tfunction ElasticEvent() {\n\t  /**\n\t   * ElasticSearch API host url\n\t   * @memberof ElasticEvent\n\t   * @example\n\t   * elasticevent.host = 'https://api.example.com/elasticsearch/';\n\t   * @default localhost:9200\n\t   * @type {string}\n\t   */\n\t  this.host = 'localhost:9200';\n\t\n\t  /**\n\t   * index value to use for the endpoint url construction\n\t   * (eg. localhost:9200/{index}/_bulk)\n\t   * @example\n\t   * elasticevent.index = 'twitter';\n\t   * @memberof ElasticEvent\n\t   * @type {string}\n\t   */\n\t  this.index = null;\n\t\n\t  /**\n\t   * type value to use for the endpoint url construction\n\t   * @example\n\t   * elasticevent.type = 'tweets';\n\t   * @memberof ElasticEvent\n\t   * @type {string}\n\t   */\n\t  this.type = null;\n\t\n\t  /**\n\t   * @typedef {string} BulkRequest\n\t   * @memberof ElasticEvent\n\t   * @example <caption>Example BulkRequest string that indexes a document</caption>\n\t   * var exampleBulkRequestString =\n\t   * '{ \"index\" : { \"_index\" : \"test\", \"_type\" : \"type1\", \"_id\" : \"1\" } }\\n\n\t   * { \"field1\" : \"value1\" }\\n'\n\t   * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html}\n\t   */\n\t\n\t  /**\n\t   * store of bulk requests\n\t   * @memberof ElasticEvent\n\t   * @private\n\t   * @type {Array.BulkRequest}\n\t   */\n\t  this.queue = [];\n\t\n\t  /**\n\t   * default max length of queue\n\t   * @memberof ElasticEvent\n\t   * @example\n\t   * elasticevent.max = 512;\n\t   * @default 256\n\t   * @type {number}\n\t   */\n\t  this.max = 256;\n\t\n\t  /**\n\t   * traits associated to all events logged may be used to identify sources\n\t   * of logs\n\t   * @memberof ElasticEvent\n\t   * @private\n\t   * @type {object}\n\t   */\n\t  this.traits = {};\n\t\n\t  /**\n\t   * interval (ms) between sending bulk request\n\t   * @memberof ElasticEvent\n\t   * @example\n\t   * elasticevent.interval = 5000;\n\t   * @default 10000\n\t   * @type {number}\n\t   */\n\t  this.interval = 10000;\n\t\n\t  /**\n\t   * interval ID of the setup repeating call\n\t   * @memberof ElasticEvent\n\t   * @private\n\t   * @type {number}\n\t   */\n\t  this.intervalSend = null;\n\t\n\t  /**\n\t   * beforeunload event handler called when 'beforeunload' event is triggered\n\t   * @memberof ElasticEvent\n\t   * @private\n\t   * @type {function}\n\t   */\n\t  this.beforeunload = null;\n\t}\n\t\n\t/**\n\t * This callback is displayed as part of the Requester class.\n\t * @callback ElasticEvent~requestCallback\n\t * @param {number} responseCode\n\t * @param {string} responseMessage\n\t */\n\t\n\t/**\n\t * [xhr description]\n\t * @memberof {ElasticEvent}\n\t * @param  {string} url       endpointl\n\t * @param  {string} content   body content\n\t * @param  {boolean} sync     set true if synchronous request\n\t * @param  {ElasticEvent~requestCallback} callback called on load, timeout or\n\t * on error\n\t * @return {object}           [description]\n\t */\n\tElasticEvent.prototype.xhr = function (url, content, sync, callback) {\n\t  var xhr = new XMLHttpRequest();\n\t\n\t  if (typeof callback === 'function') {\n\t    xhr.ontimeout = xhr.onerror = xhr.onload = function () {\n\t      var err = null;\n\t      if (!xhr.status || xhr.status >= 400) {\n\t        err = new Error(xhr.statusText || 'request failed');\n\t      }\n\t      callback(err, xhr.responseText ? JSON.parse(xhr.responseText) : null,\n\t        xhr.status, xhr);\n\t    };\n\t  }\n\t\n\t  xhr.open('POST', url, !sync);\n\t\n\t  if (content) {\n\t    // no preflight\n\t    xhr.setRequestHeader('Content-Type', 'text/plain');\n\t    xhr.send(content);\n\t  } else {\n\t    xhr.send(null);\n\t  }\n\t  return xhr;\n\t};\n\t\n\tElasticEvent.prototype.send = function (options, callback) {\n\t  var opts = options || {};\n\t\n\t  if (!this.queue.length) {\n\t    return;\n\t  }\n\t\n\t  opts.op = 'bulk';\n\t\n\t  this.request(\n\t    this.queue.splice(0, opts.max || this.max).join(''),\n\t    opts,\n\t    callback\n\t  );\n\t};\n\t\n\tElasticEvent.prototype.request = function (data, options, callback) {\n\t  var opts = options || {};\n\t  var json;\n\t  var url = opts.url || opts.host || this.host;\n\t\n\t  if (!opts.url) {\n\t    if (opts.index || this.index) {\n\t      url += '/' + (opts.index || this.index);\n\t    }\n\t    if (opts.type || this.type) {\n\t      url += '/' + (opts.type || this.type);\n\t    }\n\t\n\t    url += '/_' + (opts.op || 'search');\n\t  }\n\t\n\t  if (data && typeof data === 'object') {\n\t    json = JSON.stringify(data);\n\t  }\n\t\n\t  return this.xhr(url, json || data, opts.sync, callback);\n\t};\n\t\n\tElasticEvent.prototype.add = function (event, meta) {\n\t  var data;\n\t  var info = meta || {};\n\t  var index = {\n\t    _index: info.index || this.index,\n\t    _type: info.type || this.type\n\t  };\n\t\n\t  if (typeof event !== 'object') {\n\t    throw new Error('log event is not an object');\n\t  }\n\t\n\t  if (info.id) {\n\t    index._id = info.id;\n\t  }\n\t\n\t  data = JSON.stringify({ index: index }) + '\\n' +\n\t    JSON.stringify(event) + '\\n';\n\t\n\t  this.queue.push(data);\n\t\n\t  if (this.queue.length > this.max) {\n\t    this.send();\n\t  }\n\t};\n\t\n\tElasticEvent.prototype.baseEvent = function (event) {\n\t  var baseEvent = event || {};\n\t  var trait;\n\t\n\t  for (trait in this.traits) {\n\t    if (this.traits.hasOwnProperty(trait) &&\n\t      !baseEvent.hasOwnProperty(trait)) {\n\t      baseEvent[trait] = this.traits[trait];\n\t    }\n\t  }\n\t\n\t  return baseEvent;\n\t};\n\t\n\tElasticEvent.prototype.track = function (type, event) {\n\t  if (typeof type !== 'string') {\n\t    throw new Error('invalid type');\n\t  }\n\t\n\t  this.add(this.baseEvent(event), {\n\t    type: type\n\t  });\n\t};\n\t\n\tElasticEvent.prototype.identify = function (traits) {\n\t  var trait;\n\t  for (trait in traits) {\n\t    if (traits.hasOwnProperty(trait)) {\n\t      this.traits[trait] = traits[trait];\n\t    }\n\t  }\n\t};\n\t\n\tElasticEvent.prototype.search = function (query, options, callback) {\n\t  var opts = options || {};\n\t\n\t  opts.op = 'search';\n\t\n\t  this.request(\n\t    query,\n\t    opts,\n\t    callback\n\t  );\n\t};\n\t\n\t/**\n\t * typedef El\n\t */\n\t\n\t/**\n\t * setupIntervalSend setups the repeating call to empty the queue of logged\n\t * events, interval id is stored in this.intervalSend.\n\t *\n\t * @throws 'already setup intervalSend' if this.intervalSend is already set\n\t * @param  {object} [options] options object\n\t * @param  {number} [options.interval] interval (ms) of the repeating call\n\t * @return {void}\n\t */\n\tElasticEvent.prototype.setupIntervalSend = function (options) {\n\t  var opts = options || {};\n\t\n\t  if (this.intervalSend) {\n\t    throw new Error('already setup intervalSend');\n\t  }\n\t\n\t  this.interval = opts.interval || this.interval;\n\t\n\t  this.intervalSend = setInterval(\n\t    this.send.bind(this,\n\t      // will use instance setup options\n\t      null,\n\t      // no callback\n\t      null),\n\t    this.interval\n\t  );\n\t};\n\t\n\t/**\n\t * setupBeforeUnload setups the synchronous call before unload of html\n\t * document\n\t *\n\t * @throws 'already setup beforeUnload' if this.beforeunload is already set\n\t * @return {void}\n\t */\n\tElasticEvent.prototype.setupBeforeUnload = function () {\n\t  if (this.beforeunload) {\n\t    throw new Error('already setup beforeUnload');\n\t  }\n\t\n\t  this.beforeunload = this.send.bind(this, {\n\t    sync: true\n\t  }, null);\n\t\n\t  window.addEventListener('beforeunload', this.beforeunload);\n\t};\n\t\n\t/**\n\t * setup helper function that calls both setupIntervalSend and\n\t * setupBeforeUnload\n\t * @borrows setupBeforeUnload\n\t * @param {object} options options\n\t * @return {void}\n\t * @see {@link ElasticEvent#setupIntervalSend}\n\t * @see {@link ElasticEvent#setupBeforeUnload}\n\t */\n\tElasticEvent.prototype.setup = function (options) {\n\t  this.setupIntervalSend(options);\n\t  this.setupBeforeUnload();\n\t};\n\t\n\t/**\n\t * close empties the queue of logged events and removes the listener on\n\t * beforeunload and clears interval\n\t *\n\t * @param  {function} callback [description]\n\t * @return {void}\n\t */\n\tElasticEvent.prototype.close = function (callback) {\n\t  if (this.intervalSend) {\n\t    clearInterval(this.intervalSend);\n\t    this.intervalSend = null;\n\t  }\n\t  if (this.beforeunload) {\n\t    window.removeEventListener('beforeunload', this.beforeunload);\n\t    this.beforeunload = null;\n\t  }\n\t  self.send(null, callback);\n\t};\n\t\n\tmodule.exports = ElasticEvent;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** elastic-event.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8256de9b3d20f4b4b55a\n **/","/**\n * ElasticEvent provides a simple interface to log and query event. Requests\n * to the ElasticSearch API are sent in bulk by keeping a queue of\n * logged events that will be sent on a set interval, before\n * unload, on max size or on command.\n *\n * @class ElasticEvent\n * @constructor\n */\nfunction ElasticEvent() {\n  /**\n   * ElasticSearch API host url\n   * @memberof ElasticEvent\n   * @example\n   * elasticevent.host = 'https://api.example.com/elasticsearch/';\n   * @default localhost:9200\n   * @type {string}\n   */\n  this.host = 'localhost:9200';\n\n  /**\n   * index value to use for the endpoint url construction\n   * (eg. localhost:9200/{index}/_bulk)\n   * @example\n   * elasticevent.index = 'twitter';\n   * @memberof ElasticEvent\n   * @type {string}\n   */\n  this.index = null;\n\n  /**\n   * type value to use for the endpoint url construction\n   * @example\n   * elasticevent.type = 'tweets';\n   * @memberof ElasticEvent\n   * @type {string}\n   */\n  this.type = null;\n\n  /**\n   * @typedef {string} BulkRequest\n   * @memberof ElasticEvent\n   * @example <caption>Example BulkRequest string that indexes a document</caption>\n   * var exampleBulkRequestString =\n   * '{ \"index\" : { \"_index\" : \"test\", \"_type\" : \"type1\", \"_id\" : \"1\" } }\\n\n   * { \"field1\" : \"value1\" }\\n'\n   * @see {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html}\n   */\n\n  /**\n   * store of bulk requests\n   * @memberof ElasticEvent\n   * @private\n   * @type {Array.BulkRequest}\n   */\n  this.queue = [];\n\n  /**\n   * default max length of queue\n   * @memberof ElasticEvent\n   * @example\n   * elasticevent.max = 512;\n   * @default 256\n   * @type {number}\n   */\n  this.max = 256;\n\n  /**\n   * traits associated to all events logged may be used to identify sources\n   * of logs\n   * @memberof ElasticEvent\n   * @private\n   * @type {object}\n   */\n  this.traits = {};\n\n  /**\n   * interval (ms) between sending bulk request\n   * @memberof ElasticEvent\n   * @example\n   * elasticevent.interval = 5000;\n   * @default 10000\n   * @type {number}\n   */\n  this.interval = 10000;\n\n  /**\n   * interval ID of the setup repeating call\n   * @memberof ElasticEvent\n   * @private\n   * @type {number}\n   */\n  this.intervalSend = null;\n\n  /**\n   * beforeunload event handler called when 'beforeunload' event is triggered\n   * @memberof ElasticEvent\n   * @private\n   * @type {function}\n   */\n  this.beforeunload = null;\n}\n\n/**\n * This callback is displayed as part of the Requester class.\n * @callback ElasticEvent~requestCallback\n * @param {number} responseCode\n * @param {string} responseMessage\n */\n\n/**\n * [xhr description]\n * @memberof {ElasticEvent}\n * @param  {string} url       endpointl\n * @param  {string} content   body content\n * @param  {boolean} sync     set true if synchronous request\n * @param  {ElasticEvent~requestCallback} callback called on load, timeout or\n * on error\n * @return {object}           [description]\n */\nElasticEvent.prototype.xhr = function (url, content, sync, callback) {\n  var xhr = new XMLHttpRequest();\n\n  if (typeof callback === 'function') {\n    xhr.ontimeout = xhr.onerror = xhr.onload = function () {\n      var err = null;\n      if (!xhr.status || xhr.status >= 400) {\n        err = new Error(xhr.statusText || 'request failed');\n      }\n      callback(err, xhr.responseText ? JSON.parse(xhr.responseText) : null,\n        xhr.status, xhr);\n    };\n  }\n\n  xhr.open('POST', url, !sync);\n\n  if (content) {\n    // no preflight\n    xhr.setRequestHeader('Content-Type', 'text/plain');\n    xhr.send(content);\n  } else {\n    xhr.send(null);\n  }\n  return xhr;\n};\n\nElasticEvent.prototype.send = function (options, callback) {\n  var opts = options || {};\n\n  if (!this.queue.length) {\n    return;\n  }\n\n  opts.op = 'bulk';\n\n  this.request(\n    this.queue.splice(0, opts.max || this.max).join(''),\n    opts,\n    callback\n  );\n};\n\nElasticEvent.prototype.request = function (data, options, callback) {\n  var opts = options || {};\n  var json;\n  var url = opts.url || opts.host || this.host;\n\n  if (!opts.url) {\n    if (opts.index || this.index) {\n      url += '/' + (opts.index || this.index);\n    }\n    if (opts.type || this.type) {\n      url += '/' + (opts.type || this.type);\n    }\n\n    url += '/_' + (opts.op || 'search');\n  }\n\n  if (data && typeof data === 'object') {\n    json = JSON.stringify(data);\n  }\n\n  return this.xhr(url, json || data, opts.sync, callback);\n};\n\nElasticEvent.prototype.add = function (event, meta) {\n  var data;\n  var info = meta || {};\n  var index = {\n    _index: info.index || this.index,\n    _type: info.type || this.type\n  };\n\n  if (typeof event !== 'object') {\n    throw new Error('log event is not an object');\n  }\n\n  if (info.id) {\n    index._id = info.id;\n  }\n\n  data = JSON.stringify({ index: index }) + '\\n' +\n    JSON.stringify(event) + '\\n';\n\n  this.queue.push(data);\n\n  if (this.queue.length > this.max) {\n    this.send();\n  }\n};\n\nElasticEvent.prototype.baseEvent = function (event) {\n  var baseEvent = event || {};\n  var trait;\n\n  for (trait in this.traits) {\n    if (this.traits.hasOwnProperty(trait) &&\n      !baseEvent.hasOwnProperty(trait)) {\n      baseEvent[trait] = this.traits[trait];\n    }\n  }\n\n  return baseEvent;\n};\n\nElasticEvent.prototype.track = function (type, event) {\n  if (typeof type !== 'string') {\n    throw new Error('invalid type');\n  }\n\n  this.add(this.baseEvent(event), {\n    type: type\n  });\n};\n\nElasticEvent.prototype.identify = function (traits) {\n  var trait;\n  for (trait in traits) {\n    if (traits.hasOwnProperty(trait)) {\n      this.traits[trait] = traits[trait];\n    }\n  }\n};\n\nElasticEvent.prototype.search = function (query, options, callback) {\n  var opts = options || {};\n\n  opts.op = 'search';\n\n  this.request(\n    query,\n    opts,\n    callback\n  );\n};\n\n/**\n * typedef El\n */\n\n/**\n * setupIntervalSend setups the repeating call to empty the queue of logged\n * events, interval id is stored in this.intervalSend.\n *\n * @throws 'already setup intervalSend' if this.intervalSend is already set\n * @param  {object} [options] options object\n * @param  {number} [options.interval] interval (ms) of the repeating call\n * @return {void}\n */\nElasticEvent.prototype.setupIntervalSend = function (options) {\n  var opts = options || {};\n\n  if (this.intervalSend) {\n    throw new Error('already setup intervalSend');\n  }\n\n  this.interval = opts.interval || this.interval;\n\n  this.intervalSend = setInterval(\n    this.send.bind(this,\n      // will use instance setup options\n      null,\n      // no callback\n      null),\n    this.interval\n  );\n};\n\n/**\n * setupBeforeUnload setups the synchronous call before unload of html\n * document\n *\n * @throws 'already setup beforeUnload' if this.beforeunload is already set\n * @return {void}\n */\nElasticEvent.prototype.setupBeforeUnload = function () {\n  if (this.beforeunload) {\n    throw new Error('already setup beforeUnload');\n  }\n\n  this.beforeunload = this.send.bind(this, {\n    sync: true\n  }, null);\n\n  window.addEventListener('beforeunload', this.beforeunload);\n};\n\n/**\n * setup helper function that calls both setupIntervalSend and\n * setupBeforeUnload\n * @borrows setupBeforeUnload\n * @param {object} options options\n * @return {void}\n * @see {@link ElasticEvent#setupIntervalSend}\n * @see {@link ElasticEvent#setupBeforeUnload}\n */\nElasticEvent.prototype.setup = function (options) {\n  this.setupIntervalSend(options);\n  this.setupBeforeUnload();\n};\n\n/**\n * close empties the queue of logged events and removes the listener on\n * beforeunload and clears interval\n *\n * @param  {function} callback [description]\n * @return {void}\n */\nElasticEvent.prototype.close = function (callback) {\n  if (this.intervalSend) {\n    clearInterval(this.intervalSend);\n    this.intervalSend = null;\n  }\n  if (this.beforeunload) {\n    window.removeEventListener('beforeunload', this.beforeunload);\n    this.beforeunload = null;\n  }\n  self.send(null, callback);\n};\n\nmodule.exports = ElasticEvent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./elastic-event.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}